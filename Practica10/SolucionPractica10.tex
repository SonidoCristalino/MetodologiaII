\documentclass[10pt, spanish]{article}

\usepackage{geometry} %Necesario para poder equiparar los márgenes
 \geometry{
    a4paper,
    total={170mm,257mm},
    left=20mm,
     top=20mm,
}
\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}

\usepackage{listings}
\usepackage{color}
\usepackage{graphicx} % Necesario para poder renderizar imagenes
\usepackage{tabularx}   %Necesario para poner la orientacion de {tabular} en 'medio'

\lstloadlanguages{C,C++,csh,Java}

\definecolor{red}{rgb}{0.6,0,0}
\definecolor{blue}{rgb}{0,0,0.6}
\definecolor{green}{rgb}{0,0.8,0}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}
\definecolor{cloudwhite}{rgb}{0.9412, 0.9608, 0.8471}

\lstset{
    language=csh,
    basicstyle=\footnotesize\ttfamily,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    tabsize=2,
    extendedchars=true,
    breaklines=true,
    frame=b,
    stringstyle=\color{blue}\ttfamily,
    showspaces=false,
    showtabs=false,
    xleftmargin=17pt,
    framexleftmargin=17pt,
    framexrightmargin=5pt,
    framexbottommargin=4pt,
    commentstyle=\color{green},
    morecomment=[l]{//}, %use comment-line-style!
    morecomment=[s]{/*}{*/}, %for multiline comments
    showstringspaces=false,
    morekeywords={ abstract, event, new, struct,
    as, explicit, null, switch,
    base, extern, object, this,
    bool, false, operator, throw,
    break, finally, out, true,
    byte, fixed, override, try,
    case, float, params, typeof,
    catch, for, private, uint,
    char, foreach, protected, ulong,
    checked, goto, public, unchecked,
    class, if, readonly, unsafe,
    const, implicit, ref, ushort,
    continue, in, return, using,
    decimal, int, sbyte, virtual,
    default, interface, sealed, volatile,
    delegate, internal, short, void,
    do, is, sizeof, while,
    double, lock, stackalloc,
    else, long, static,
    enum, namespace, string},
    keywordstyle=\color{cyan},
    identifierstyle=\color{red},
    backgroundcolor=\color{cloudwhite},
}

\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{blue}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

% ----------------------------------------------------------------------
%                       PRESENTACION
% ----------------------------------------------------------------------

\author{Emiliano Salvatori}
\title{Metodología de la programación II \\
    \large Practica X}
\date{Octubre 2019}
\pagestyle{headings}

\begin{document}
\maketitle

% ----------------------------------------------------------------------
%                       INTRODUCION
% ----------------------------------------------------------------------
\section{Practica X}

\subsection*{Refactorización}

Responda las siguientes preguntas e indique las fuentes de información que utilizó.

\subsubsection*{¿Qué es un código simple? ¿qué características tiene?}

Las características de un código simple son las siguientes:
\begin{itemize}
    \item
        Funciona bien.
    \item
        Comunica bien lo que esta haciendo.
    \item
        No tiene duplicación.
    \item
        Tiene el menor número posible de clases y método.
\end{itemize}

Y a su vez proporciona los siguientes beneficios:
\begin{itemize}
    \item
        El código es más fácil de cambiar, evolucionar o arreglar.
    \item
        El código es más fácil de leer y entender.
    \item
        Es más fácil hacerlo bien desde la primera vez, así estamos programando más rápido.
\end{itemize}

\subsubsection*{¿Qué significa \emph{refactorizar}?}

Refactorizar significa cambiar el código internamente sin alterar su funcionalidad externa.  En general, con motivos de
mejorar el diseño y obtener un código más simple.

\subsubsection*{¿En qué consiste la refactorización?}

La Refactorización enseña técnicas para descubrir el código de mala calidad y técnicas para cambiarlo.

En el proceso es importante contar con un buen lote de casos de prueba que validen el correcto funcionamiento del
sistema.

Los pasos a seguir son los siguientes:
\begin{itemize}
    \item
        Ejecutar las pruebas, para obtener información sobre el comportamiento actual del sistema.
    \item
        Analizar los cambios a realizar.
    \item
        Aplicar los cambios.
    \item
        Ejecutar las pruebas y corroborar que los resultados antes y luego de efectuada la refactorización son iguales.
\end{itemize}

\subsubsection*{¿Qué diferencia hay entre optimizar y refactorizar?}

La diferencia es que:
\begin{itemize}
    \item
        En ambos casos se modifica el código fuente sin alterar el comportamiento observable del software.
    \item
        En la optimización se le suele agregar complejidad al código.
\end{itemize}

\subsubsection*{¿Cuáles son las ventajas que ofrece el proceso de refactorización?}

Los aspectos favorables son:
\begin{itemize}
    \item
        Favorece el mantenimiento del diseño del sistema.
    \item
        Facilita la lectura y comprensión del código fuente.
    \item
        Facilita la detección temprana de errores.
    \item
        Permite programar mas rápido, lo que eleva la productividad de los desarrolladores.
\end{itemize}

\subsubsection*{¿En qué situaciones se debe refactorizar y cuándo no tiene sentido hacerlo?}

Hay que refactorizar cuando:
\begin{itemize}
    \item
        Estamos agregando nueva funcionalidad al código.
    \item
        Estamos solucionando una falla.
    \item
        Estamos haciendo revisión de código (Distribución del conocimiento dentro del equipo de desarrollo).
\end{itemize}

Se debe evitar hacerlo cuando:
\begin{itemize}
    \item
        Es más fácil hacerlo de nuevo.
    \item
        El código no funciona.
    \item
         Demasiado cerca de la fecha de entrega comprometida.
\end{itemize}

\subsubsection*{¿Qué problemas ocasionan los Métodos Largos? ¿qué deberíamos de hacer para eliminarlos?}

Los Métodos Largos en el código, suelen tener las siguientes defectos:
\begin{itemize}
    \item
        Dificultan mucho su comprensión.
    \item
        Seguramente realizan más de una responsabilidad.
    \item
        En la POO cuando más corto es un método más fácil su reutilización.
    \item
        Programas con métodos mas cortos, tienen vida mas larga.
\end{itemize}

Para eliminarlos se sugiere detectar las diferentes responsabilidades y sacarlas a métodos o clases nuevas.

\subsubsection*{¿A qué nos referimos cuando hablamos de ''Envidia de Funcionalidades''?}

Lo que se denomina ''Envidia de Funcionalidades'' contiene contiene las siguientes características:
\begin{itemize}
    \item
        Métodos de una clase más interesados en datos de otra clase que en los datos suyos.
    \item
        La envidia de la Clase A por recursos de la Clase B es una indicación del acoplamiento fuerte de la Clase A con
        la Clase B.
\end{itemize}

Las posibles soluciones a esto son:
\begin{itemize}
    \item
        Mover la funcionalidad del método de Clase A a la Clase B, que ya está más cerca de la mayoría de datos
        implicados en la tarea.
    \item
        Extraer a un método el código envidioso y mover sólo ese método a la Clase B.
\end{itemize}

\subsubsection*{¿Qué significa ''Legado rechazado''? ¿Cómo podemos resolver este problema?}

Es cuando el código en la POO tiene las siguientes características:
\begin{itemize}
    \item
        Subclases que usan sólo pocas características de sus superclases.
    \item
        Si las subclases no necesitan o no requieren todo lo que sus superclases les proveen por herencia, esto suele
        indicar que como fue pensada la jerarquía de clases no es correcto.
\end{itemize}

La posible solución es utilizar la \emph{Delegación} para subsanar los posibles errores de diseño.

\subsubsection*{Describa la técnica ''Extraer Método''. Dé un ejemplo donde se utilice dicha técnica}

En la técnica denominada ''Extraer método'', los pasos a seguir son los siguientes:
\begin{itemize}
    \item
        Se tiene un fragmento de código que es posible agrupar:
        \begin{center}
        \includegraphics[width=90mm,scale=0.3]{imagen1.png}
        \end{center}
    \item
        Se transforma el fragmento a un método nuevo cuyo nombre va a explicar su propósito:
        \begin{center}
        \includegraphics[width=90mm,scale=0.3]{imagen2.png}
        \end{center}
\end{itemize}

\end{document}
