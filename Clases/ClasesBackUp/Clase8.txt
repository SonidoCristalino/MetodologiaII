Fecha de Examen: 5 de noviembre. 

Uso de las pseudo variables self y super:
----------------------------------------

La herencia en Smaltallk es total. No hay herencia múltiple. Toda la clase hereda todo lo de la superclase. 
Si no se quiere heredar determinado método, lo que hay que hace res REDEFINIR el método en la clase nueva, para que no
herede de la superclase. 

Si se tiene un método en la superclase y si en una de las dos clases que heredan de ella, se rededefine el método,
   entonces toma primero el método definido en la clase, y no el de la superclase. 

ctaBancaria>>depositar:unMonto
    saldo:=saldo + unMonto

    >>verSaldo
    ^saldo

    >>extraer:unMonto


Opción 1 : Mala forma de implementarlo. 
---------
La idea es que la función que que se implemente en la superclase, esté definida tanto para la clase CajaDeAhorro y la
CtaCorriente. 

Ejemplo: extraer() en una superclase: CtaBancaria. 
2 Clases que heredan: CajadeAhorro y CtaCorriente. 

El método malo es que se defina el extraer() para que cada uno lo entienda en su propia clase. 
Por ejemplo, si se hace extraer() de CajaDeAhorro, primero se fija si está en la clas CajaDeAhorro, y si no lo
encuentra, entonces se fija la definida en la Superclase

        CtaBancaria
        ------------
        nroCuenta
        titular
        Saldo
        ============
        Depositar()
        extraer()
        verSaldo()
        -------------

        CajaDeAhorro
        ------------
        cantExtraer
        ============
        incrementarExtraccion()
        ------------

        CtaCorriente
        ------------
        SaldoEnRojo
        ============

        ------------

>>extraer : unMonto
(saldo >= unMonto) ifTrue:[saldo := saldo - unMonto
                                self incrementarExtraccion()]

    self hace referencia a la INSTANCIA del objeto que inició el mensaje, por ende sería la instancia de CajaDeAhorro,
    ya que sólo ahí estaría implementada la función incrementarExtraer() y no en CuentaBancaria. 


Opción 2: No es tan mala
--------

Lo que sería es implementar en cada subclase, un método para que lo entienda cada una de las subclases. Pero a
diferencia de la opción 1 sea las subclases la que lo implementen. 

        CtaBancaria
        ------------
        nroCuenta
        titular
        Saldo
        ============
        Depositar()
        verSaldo()
        -------------

        CajaDeAhorro
        ------------
        cantExtraer
        ============
        extraer()
        incrementarExtraccion()
        ------------


        CtaCorriente
        ------------
        SaldoEnRojo
        ============
        extraer()
        ------------

Si se ejecuta extraer() se implementa primero el método que esté en la clase, luego si no está entonces va a la
superclase. En caso de que ambas subclases (como en este ejemplo) tengan implementado el extraer(), NO SE DEBE borrar la
el méodo extraer() de la superclase, porque "define cómo se debe comportar una clase"


Opción 3: opción óptima
--------
Lo que se hace es definir una sola vez en la superclase, pero las superclases lo entienden A SU FORMA. 

        CtaBancaria
        ------------
        nroCuenta
        titular
        Saldo
        ============
        Depositar()
        extraer()
        verSaldo()
        -------------

        CajaDeAhorro
        ------------
        cantExtraer
        ============
        incrementarExtraccion()
        ------------


        CtaCorriente
        ------------
        SaldoEnRojo
        ============
        ------------

Extraer se puede descomponer en operaciones. 
    1 Verificar si la cuenta está habilitada: ¿Qué significa en una caja de ahorro y en una cuenta corriente?
    2 Verificar si la operación es válida: ¿Qué significa en una caja de ahorro y en una cuenta corriente?
    3 Realizar operación: ¿Qué significa en una caja de ahorro y en una cuenta corriente?

1) Las validaciones serán distintas para CA y de CC. Como son diferentes, debe de existir una operación en CA
verificarCuenta() y uno en CC también con el mismo nombre VerificarCuenta
2) En CA es válida cuando el saldo es >= que el monto. En CC el saldo => saldo en rojo + saldo por o que ambas son
distintas, y se debería implementar como verificarOperacion() en CA y verificarOperacion() en CC, si por ejemplo las
las operaciones serían igual en CC que en CA, entonces debe ser definido en la superclase. 
3) se crea un método CA y CC distinto pero con el mismo nombre: realizarOperacion(). 

extraer() en cuenta Bancaria: 
    ctaBancaria>>extraer: unMonto
                (self verificarCuenta) && (self verificarOperacion:unMOnto) 
                    ifTrue:[self realizarOperacion: unMonto]


ver que extraer() no está definida en las subclases, sino que en la superclase. Con 1 solo extraer se resuelven TODOS.
Lo que si hay, son distintas operaciones para cada una de las subclases. Se agregan todas las clases que uno quisiera,
   pero tendría el mismo fin, que sería extraer un monto. 

Cuando se utiliza super, hace referencia al método de la superclase. Si se puede hace uso de manera indistinta, entonces
utilizar SELF. ¿En qué momento se podría utilizar SUPER? Cuando se inicializan las clases de la subclase, para
inicializar las variables tipicas de la superclase. ¿por qué? No se terminó de entender. 

==============
Parte Practica
==============
Jerarquía: 
        A
        |
        B
        |
        C

        Clase A: 
            >>m1
            ^ 2
            >>m2
            ^ 15
            >>m3
            ^ self m6 + self m2
            >>m6
            ^ self m2

        Clase B: 
            >>m1
            ^ 5
            >>m4
            ^ self m2 + super m3
            >>m3
            ^ 3
            >>m6
            ^ self m2

        Clase C: 
            >>m1
            ^ self m4
            >>m2
            ^ 6
            >>m7
            ^ super m6

|unObjeto|
unObjeto := c new
(unObjeto m7) inspect
(unObjeto m1) inspect

(unObjeto m7) inspect: 
            >>m7        = llamada a C
            ^ super m6
            >>m6        = llamada a B
            ^ self m2
            >>m2        = llamada a C
            ^ 6 ----> devuelve 6 OK

        Cada vez que hace Self, se debe buscar en la clase que instancia el self, y si no lo encuentra, entonces sub

(unObjeto m1) inspect
            >>m1
            ^ self m4
            >>m4
            ^ self m2 + super m3
                6    + 30    = 45 ---> devuelve 45 ¡¡NO!! Cuando es self, automáticamente va a C, que es el unObjeto,
                SIEMPRE comienza desde la clase que se instancia, por ende acá es: 

            >>m1
            ^ self m4
            >>m4
            ^ self m2 + super m3
               6    + self m6 + self m3
               6    + self m2 + self m2 --> ver que acá va a C, y no a la clase que lo llamó. 
               6    + 6     + 6 = 18

----------------------------
Lo que se toma en el parcial: 
----------------------------
    - Diferencia entre un Framework y un Patrón. 
    - Qué es la Refactorización, qué significa, en qué casos se usaría, 

Rendir parte teorica: 
   - Que tiene que ver con clas prácticas. 

Practica se toma: 
    - Ejercicio como el de Self y Super anterior
    - Tipos de mensaje:  unarios, anidados, etc ¿Cómo se resuelven? 
        1) Parentesis
        2) Unarios
        3) Binarios
        4) De palabra clave

    Smalltalk: 
        - Poder crear una instancia de una clase. 
        - Cargar una instancia con datos. 
        - Do, to: do:, ifTrue, whileTrue
        - Select, collect, reject, detect



